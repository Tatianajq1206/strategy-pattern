Analisis adicional del codigo del profesor

La función `sort_graph` se encarga de organizar la lista de aristas del grafo según el peso de las aristas. 
Sin embargo, se señala que esta función es ineficiente ya que utiliza la lista original repetidamente para 
comparar los pesos, lo que resulta en un proceso de ordenación lento. Aunque utiliza una estrategia de dividir 
y conquistar, donde divide la lista en sublistas más pequeñas y luego las combina en orden, la recursión puede 
ser ineficiente debido al manejo inadecuado de la lista original. Además, se señala que la función no está 
siendo utilizada en ninguna parte del código, lo que sugiere una falta de coherencia en la implementación.

La función `search_objetive` implementa una búsqueda binaria recursiva para encontrar un objetivo dentro de la
lista de aristas. Se menciona que esta función también puede tener problemas de eficiencia debido a la recursión
sin límite explícito, lo que puede provocar un desbordamiento de pila en casos extremos. Además, el proceso de 
búsqueda puede ser prolongado si el objetivo no está presente en la lista de aristas debido a la manera en que 
se divide la lista en cada iteración.

La función `bad_graph_algorithm` intenta encontrar la ruta más fácil entre el nodo objetivo y el nodo de inicio. 
Sin embargo, se señala que esta función tiene varios problemas, incluida la recursividad infinita si se conecta 
con `search_objetive` y la falta de consideración de todas las posibles rutas para elegir la mejor opción. 
También se indica que el código lanza un error si el nodo de inicio es igual al nodo objetivo, lo que sugiere 
una falta de manejo de excepciones en el código.

En la función `main`, se mencionan algunas observaciones sobre el comportamiento del programa al manipular los 
nodos de inicio y fin. Se señala que el código asume que se debe trabajar con un grafo dirigido, lo que limita 
las opciones si se desea ir desde el nodo final hasta el nodo inicial. Además, se menciona que llamar a la función 
`sort_graph` no afecta el resultado ya que no se utiliza en ninguna parte del código.

Para resumir, aunque el código intenta abordar el problema de encontrar la ruta más corta en un grafo ponderado, 
presenta varias deficiencias en términos de eficiencia, manejo de excepciones y coherencia en la implementación. 
Se recomendaría realizar mejoras significativas en la lógica del programa y en la gestión de datos para lograr 
un funcionamiento óptimo y robusto.

//--------------------------------------------------------------------------------------------------------------

Analisis del codigo que realice 

La función `pass_graph` tiene como objetivo duplicar cada arista en la lista de aristas, invirtiendo el orden del 
nodo de inicio y fin. Esta función es eficiente en términos de tiempo de ejecución ya que itera sobre la lista de 
aristas una vez, creando una copia invertida de cada arista. La función devuelve una lista de aristas modificada 
que contiene tanto las aristas originales como las invertidas.

La función `peso_menor` busca la arista con el menor peso en una lista de aristas, comparando la posición [2] 
(el peso) de cada arista. Esta función es esencial para la implementación del algoritmo de búsqueda del camino 
más corto.

La función `camino_corto` busca recursivamente el camino más corto entre dos nodos en un grafo dado. Utiliza un 
enfoque de búsqueda recursiva para explorar las posibles rutas desde el nodo de inicio hasta el nodo objetivo. 
La función mantiene una lista de aristas a considerar (`comparar`) y una lista de aristas que forman el camino 
más corto (`camino`). La recursión continúa hasta que no hay más aristas para considerar en `comparar`, momento 
en el que se devuelve el camino actual.

La función `graph_algorithm` envuelve la función `camino_corto`, asegurando que los nodos de inicio y fin no sean 
iguales. Si los nodos de inicio y fin son iguales, la función devuelve un error de valor, evitando así la búsqueda 
de un camino entre un nodo y sí mismo.

En la función `main`, se establecen las entradas del programa y se ejecutan las funciones relevantes para encontrar 
el camino más corto entre dos nodos específicos en el grafo. Se realiza un intento de encontrar el camino más corto 
entre los nodos 3 y 0 después de invertir las aristas utilizando `pass_graph`. Si se encuentra un camino, se imprime 
cada camino encontrado; de lo contrario, se imprime un mensaje de error si los nodos de inicio y fin son iguales, 
evitando así la ejecución de un algoritmo de búsqueda innecesario.

En conclución, el código presenta una implementación eficiente y funcional para encontrar el camino más corto en un
gráfico dado. Se utiliza un enfoque recursivo para explorar posibles caminos y garantizar que el nodo inicial
y diferentes finales para evitar posibles problemas. Las excepciones implementadas evitan búsquedas innecesarias
una ruta cuando los nodos inicial y final son los mismos.

//----------------------------------------------------------------------------------------------------------------

Comparacion de los codigos

En el código del profesor, se emplean funciones como `sort_graph`, `search_objetive`, y `bad_graph_algorithm` para
organizar las aristas, buscar el objetivo, y encontrar la ruta más fácil, respectivamente. Sin embargo, se 
identificaron problemas de eficiencia, manejo de excepciones y coherencia en la implementación. Por ejemplo, 
`sort_graph` se considera ineficiente debido a la forma en que utiliza la lista original repetidamente, lo que 
ralentiza el proceso de ordenación. Además, `bad_graph_algorithm` presenta problemas de recursividad infinita y 
falta de consideración de todas las posibles rutas.

Por otro lado, en mi código, se introdujeron mejoras significativas para abordar estas deficiencias. Por ejemplo, 
en lugar de ordenar la lista original repetidamente, implementé la función `pass_graph` para duplicar las aristas 
de manera eficiente, invirtiendo el orden del nodo de inicio y fin. Esto mejoró la eficiencia del proceso de 
ordenación. Además, se implementó la función `graph_algorithm` para envolver `camino_corto`, asegurando que los 
nodos de inicio y fin no fueran iguales para evitar problemas de búsqueda innecesaria de un camino entre un nodo 
y sí mismo.

Se utilizaron excepciones para manejar casos específicos, como cuando los nodos de inicio y fin son iguales, evitando
así la ejecución de un algoritmo de búsqueda innecesario y la posibilidad de resultados incorrectos. Además, se 
emplearon condiciones para garantizar que las funciones se ejecutaran correctamente, como en el caso de `peso_menor`, 
donde se verificó si la lista estaba vacía antes de continuar con la búsqueda del peso más bajo.

En resumen, las mejoras implementadas en mi código abordaron eficazmente los problemas identificados en el código 
del profesor, mejorando la eficiencia, el manejo de excepciones y la coherencia en la implementación. Se utilizaron 
funciones como `pass_graph`, `graph_algorithm`, y `peso_menor` para abordar estos problemas y garantizar un 
funcionamiento óptimo y robusto del algoritmo de búsqueda del camino más corto en un grafo.
